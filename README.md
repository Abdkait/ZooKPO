# Московский зоопарк: ERP-система для учета животных и инвентаря

## Описание проекта

Проект представляет собой консольное приложение для учета животных и инвентаря в Московском зоопарке. Основные функции:
- Добавление новых животных в зоопарк.
- Проверка здоровья животных перед приемкой.
- Учет количества еды, потребляемой животными.
- Формирование списка животных, которые могут быть помещены в контактный зоопарк.
- Учет инвентаря зоопарка (вещи, животные).

## Функциональные требования

1. **Добавление новых животных**: Возможность добавлять новых животных в зоопарк.
2. **Проверка здоровья**: Перед приемкой животного проверяется его состояние здоровья с помощью ветеринарной клиники.(логика не реализована, принмиает всех)
3. **Учет еды**: Возможность получить информацию о количестве еды, необходимой всем животным.
4. **Контактный зоопарк**: Возможность получить список животных, которые могут быть отправлены в контактный зоопарк (доброта выше 5 баллов).

## Применение принципов SOLID

В проекте были применены принципы SOLID для обеспечения гибкости, расширяемости и поддерживаемости кода.

### 1. **Принцип единственной ответственности (SRP)**

Каждый класс в проекте имеет только одну причину для изменения. Например:

- Класс `Animal` отвечает только за хранение информации о животном (имя, количество еды и т.д.).
- Класс `VetClinic` отвечает только за проверку здоровья животных.

Пример:
```java
public class Animal {
    private final int food;
    // Конструктор и методы для работы с данными животного
}

public class VetClinic {
    public boolean checkHealth(Animal animal) {
        // Логика проверки здоровья
    }
}
```

### 2. **Принцип открытости/закрытости (OCP)**

Классы и модули проекта открыты для расширения, но закрыты для модификации. Например:

- Класс `Herbo` может быть расширен для добавления новых типов животных (например, `Monkey`, `Rabbit`), без изменения существующего кода.
- Использование интерфейсов, таких как `InventoryInterface`, позволяет добавлять новые типы инвентаря без изменения существующей логики.

Пример:
```java
public interface InventoryInterface {
    int getNumber();
}

public class Table implements InventoryInterface {
    @Override
    public int getNumber() {
        // Логика получения номера
    }
}

public abstract class Herbo extends Animal {
    protected int kindness;

    public Herbo(HerboParams params) {
        super(new AnimalParams(params.food()));
        this.kindness = params.kindness();
    }
}

public class Monkey extends Herbo {
    public Monkey(HerboParams params) {
        super(params);
    }
}
```

### 3. **Принцип подстановки Барбары Лисков (LSP)**

Наследуемые классы могут быть использованы вместо базовых классов без изменения поведения программы. Например:

- Классы `Herbo` и `Predator` наследуются от `Animal` и могут быть использованы везде, где ожидается объект типа `Animal`.
- Классы `Table` и `Computer` реализуют интерфейс `InventoryInterface` и могут быть использованы везде, где ожидается объект этого интерфейса.

Пример:
```java
Animal rabbit = new Rabbit(new HerboParams(10, 5));
```
примеры для интерфейсов помогли бы в дальнейшей разработке, пока так :)

### 4. **Принцип разделения интерфейса (ISP)**

Интерфейсы в проекте разделены на мелкие и специфичные. Например:

- Интерфейс `InventoryInterface` содержит только метод getNumber(), который необходим для инвентаризации.
- Интерфейс `AliveInterface` содержит только метод getFood(), который необходим для работы с живыми сущностями.

Пример:
```java
public interface AliveInterface {
    int getFood();
}

public interface InventoryInterface {
    int getNumber();
}
```

### 5. **Принцип инверсии зависимостей (DIP)**

Высокоуровневые модули не зависят от низкоуровневых модулей. Оба типа модулей зависят от абстракций. Например:

- Класс `Zoo` зависит от абстракции `Animal`, а не от конкретных реализаций (например, `Rabbit` или `Tiger`).
- Внедрение зависимостей (DI) через Spring позволяет легко заменять реализации, не изменяя код.

Пример:
```java
@Service
public class Zoo {
    private final List<Animal> animals;

    @Autowired
    public Zoo(List<Animal> animals) {
        this.animals = animals;
    }
}
```